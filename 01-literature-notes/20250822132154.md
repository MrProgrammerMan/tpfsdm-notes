---
title: Chapter 1.1 Software deployment
id: 20250822132214
tags: []
---

# Chapter 1.1 Software deployment
Deploying software means taking software from a developers machine and putting it on an end-users machine. The software has to function, and support upgrading/uninstalling.

Assuming the software works on the developers machine, ensuring it does so on the end-users machine as well is _correct deployment_.

While we can simply copy relevant files from the developers machine to the end users, this has a number of problems. These are divided into 2 categories below.
## _Environment issues_
These are issues with the environment the software exists in. Other software can be required, configuration files, etc. In order to ensure correct deployment we must both identify all of a components requirements on its environment, and realize those requirements.
  - All dependencies of the software must be specified. This is tricky to test, as software may still work if the dependency happens to be installed.
  - Build-time dependencies must also be specified in the case of _source-based_ deployment, common in open source.
  - Compoents can vary in version and configuration. A component may be dependent on certain other components with specific properties. This must be specified.
  - Present dependencies has to be found by the component, often requiring a lot of manual configuration.
  - Components can require files or data such as database contents or state.
  - Components can require certain hardware. This is not something we can fix if it's not present at deployment.
  - Components can depend on services running on other machines.
## _Manageability issues_
In addition to ensuring a correct and predictable environment, we must support the entire evolution of our software. That means the ability to upgrade, transer, install, uninstall, etc. Some ways improper handling can lead to problems:
- We must know what steps to take to safely remove a component, while not removing components other parts of the system are dependent on.
- When we upgrade a component, we have to make sure we don't remove an older version some other component is dependent on. (See DLL Hell, bit rot).
- We need to answer questions like how much space is required for a component, which component a file belongs to, etc.
- Sometimes, administrators want updates to happen periodically. For indivual users, they may want to select their own components.
- We need to be able to undo or roll back upgrades. We must remember, and be able to reproduce, the old configuration.
- Staying up-to-date is important for security. We need to now what is in use, if updates are available, and if they should be applied.
- When deploying in binary form, many versions (target arcihtecture, operating system, configuration options) may have to be built. This can cause clutter and make it difficult to manage deployments.
- We need to be able to expose configuration options in certain cases.