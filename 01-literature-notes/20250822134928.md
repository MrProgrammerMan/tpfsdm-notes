---
title: Chapter 1.2 The state of the art
id: 20250822134956
tags: []
---

# Chapter 1.2 The state of the art
Below are some current strategies to software deployment.
It's shown that package management can make or break a Linux distro.
Due to Linux's insistance on global namespaces and fine-grained dependency sharing, a package management tool is necessary.

## RPM
A low-level, mature tool widely used.
RPM works by wrapping a software component into an RPM package. This includes the source files as well as meta-data about the component. It's built from a spec file that details the dependencies and installation process. RPM supports:
- upgrading
- uninstalling
- tracking of files belonging to the component
- a cryptographic hash protects against tampering
- prevents uninstalling of dependencies in use
It does not provide a way to transfer packages between machines(which is ok to seperate concerns).
Some problems with RPM:
- It does not support multiple versions of the same package on a system.
- It cannot verify dependency requirements in the spec file. Unspecified dependencies may only break the component once on the end-users machine, which is missing the dependency.
- It relies on _nominal_ dependencies. This means that **any** component by the specified name/version satisfies the dependency, even if it is an incompatible component, or it's been updated, changing it's interface.
- A library may be updated in order to install a component, breaking another component relying on the older version of the library.
- Upgrades are not atomic. New installations may overwrite old ones, creating a gap in time where there is no functioning version of the component installed. This can also make it hard to roll back in case of a failure.
- While RPM may flag missing dependencies, it cannot obtain them on its own. (This is actually not that bad, as higher level tools can build on top of RPM and implement this. An example is yum.)

## Source deployment
Source deployment offers some advantages:
- Configurability. (sytem admins, devs, etc)
- Shared dependencies need not be stored in multiple copies, as in monolithic binary deployment.

FreeBSD is a typical example of source deployment. It involves using Makefiles that describe dependencies and build/install steps. Editing the Makefile and associated files can change the configuration.

The downside of source deployment is the resource requirements to build the component and store temporary files. It also requirements additional build time dependencies.

## Windows & Mac
Windows and MacOS generally use _monolithic deployment_, where the dependencies are distributed along with the component. This means:
- No sharing of dependencies
- Doesnt help with deployment on the developers side

Windows suffers from a global namespace used for libraries, causing interference between applications that use the same libraries. (i.e.: DLL Hell).

## .NET
.NET improves on this by allowing globally unique "_strong names_". Unfortunately this only helps in the case of shared components, and only applies to _.NET assemblies_.

## Other systems
There has been several attempt to provide a better solution to deployment and installation. However, each solution hass problems resulting in deployment issues or problems with user adoption.
