---
title: Chapter 2.1 The Nix store
id: 20250824135415
tags: []
---

# Chapter 2.1 The Nix store
Nix is a system for software deployment of components. A component is the basic unit of deployment and can be any file(s).
Components are stored in an isolated manner in the _component store_, the _nix store_, which is just a directory.

The name of a component includes a cryptgraphic hash of all inputs used to build the component. This means that any slight change in a component will change the hash, making it a unique and seperate component. Therefore, several versions or configurations of components can exists side-by-side.
The hash enables complete identification of dependencies and prevent component interference. As the hash is computed recursively, a change in a dependency is a change in the component depending on it.

Once a component is built, it is marked as read-only(it is immutable). Upgrading a component happens by reabuilding the entire component, causing a new component to be created. Thus, the hash(combination of **all** build inputs) is always, not just at build time, a unique identifier of the component.

One problem with dependency identification is the use of globally available dependencies. Often times a tool like a compiler or linker will look in standard locations for certain dependencies. There is nothing preventing this from happening. However, if we _only_ store our components in the component store, the action will simply fail. This means that build-time dependencies must be explicitly defined in order to be used.
As for runtime dependencies, we can use a technique of searching the binary files for appearences of a nix hash. This is not necessarily a fool-proof strategy, which is discussed in a later chapter.
In addition to the use of globally unique identifiers, the building process is made as pure as possible. For example, the PATH variable is empty when a component is built.

All of this means that if a dependency has not been specified, the component **_will fail_**. This is important, as it makes it a lot easier to identify faulty deployment.

In order for complete deployment to happen, we need to be able to compute the _closure_ of a component. That is, a complete description of the component, how to install it, and it's recursive dependencies. Because Nix enforces globally unique component names with hashes, we know all of this.