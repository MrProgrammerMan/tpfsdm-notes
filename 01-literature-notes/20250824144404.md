---
title: Chapter 2.2 Nix expressions
id: 20250824144428
tags: []
---

# Chapter 2.2 Nix expressions
Nix can be a confusing term, as it refers to several parts of the Nix system. One of the common meanings is the Nix programming language, which is a purely functional turing complete language. In Nix, everything is an expression. Expressions are evaluated to a concrete value, which can be a number, a string, a list of these, a set of different combinations of these, and so on. Expressions are lazy, meaning they only evaluate once they're needed.

A function is a type of expression. Anything the function depends on _must_ be passed as a parameter, else calling the function will fail. If a function returns data representing a build recipe for a software component or package, it is called a derivation. A derivation is instructions for building something. Realizing a derivation means following the instructions to build the component/package/app. In order to do this, Nix must compute a closure of the component, which is a complete list of all dependencies of the component. These will themselves have derivations described for them.

Basically, in order to build a component(meaning it's placed in the Nix Store):
1. A build script must be written. This describes how to take the sources(code, configuration files, etc) and building them into a finished component that implements some functionality through an interface.
2. A nix expression must be written that returns a derivation for the component. This expression is returned from a function that must specify all dependencies of the component. Otherwise, realizing the derivation produced by the function will fail.
3. The expression written must be composed, meaning it's called, usually in a top-level file that returns a complete configuration of a system.

A part of building a component is to compute a closure of the component, meaning a complete recursive list of the components dependencies. This allows Nix to place all artifacts involved in the component in the nix store, each at a unique path. This is in essence what allows nix to support the modular and safe dependency sharing. (which is kind of the point of nix).

## 